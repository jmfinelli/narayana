name: dispatcher

on:
  pull_request:
    types: [ opened, edited, synchronize, ready_for_review, reopened ]

permissions:
  contents: read
  pull-requests: write
  checks: write
  actions: write

jobs:
  dispatcher:
    runs-on: ubuntu-latest

    steps:
      - name: Parse PR description and trigger workflows
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            const prBody = pr.body || "";

            if (!prBody) {
              core.info('PR body is empty. No test will be started.');
              return;
            }

            if (prBody.includes('NO_TEST')) {
              core.info('PR description contains `NO_TEST`. Skipping testing axes.');
              return;
            }
            
            const workflowMap = {
              'CORE': 'core.yml',
              'AS_TESTS': 'as_tests.yml',
              'RTS': 'rts.yml',
              'JACOCO': 'jacoco.yml',
              'XTS': 'xts.yml',
              'QA_JTA': 'qa_jta.yml',
              'QA_JTS_OPENJDKORB': 'qa_jts.yml',
            };

            // Convert "! AXIS" to "!AXIS"
            const processedBody = prBody.replace(/!\s+/g, '!');
            // Normalise description: replace newlines and commas with spaces and split the result into a set of tokens
            const tokens = new Set(processedBody.replace(/[\r\n,]/g, ' ').split(/\s+/));

            for (const [axis, workflowFile] of Object.entries(workflowMap)) {
              if (tokens.has(axis) && !tokens.has(`!${axis}`)) {
                core.info(`Detected axis ${axis}. Triggering ${workflowFile}...`);

                const checkRun = await github.rest.checks.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: axis,
                  head_sha: pr.head.sha,
                  status: "in_progress",
                  started_at: new Date().toISOString(),
                  output: {
                    title: `${axis} tests started`,
                    summary: `Detected ${axis} axis. Dispatching ${workflowFile}...`
                  }
                });

                try {
                  await github.rest.actions.createWorkflowDispatch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflowFile,
                    ref: pr.head.ref,
                    inputs: {
                      pull_request_number: pr.number.toString(),
                      pull_request_ref: pr.head.ref
                    }
                  });

                  await github.rest.checks.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    check_run_id: checkRun.data.id,
                    status: "completed",
                    conclusion: "neutral",
                    completed_at: new Date().toISOString(),
                    output: {
                      title: `${axis} tests dispatched`,
                      summary: `${workflowFile} workflow has been dispatched successfully and will appear in the Actions tab.`,
                    },
                  });

                } catch (error) {
                  core.error(`Failed to trigger ${workflowFile}: ${error.message}`);
                  await github.rest.checks.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    check_run_id: checkRun.data.id,
                    status: "completed",
                    conclusion: "failure",
                    completed_at: new Date().toISOString(),
                    output: {
                      title: `Failed to start ${axis} tests`,
                      summary: `Error: ${error.message}`,
                    },
                  });
                }
              } else {
                core.info(`Axis ${axis} not requested or explicitly negated.`);
              }
            }